design priorities

1. it's easy to notate score components (any score component can be notated).

2. all score components are instantiated in a notatable state and no score
component can ever be put in a non-notatable state. we might call this the
"principle of conservation of (score component) notatability." second
principle: class authors may equip even the most abstract classes with an
optional illustration: this is what we mean when we refer to our illustration
protocol. we might call this second principle a "principle of universal
illustration".

2.5 we provide factories. factory functions. factory classes. when we wanna
make complex stuff we usually come up with factories. (there may be a design
principle here that initialization is kept simple and we implement in factories
complex ways of aggregating together objects that admit only simple
initialization.)

2.75 input flexibility: you can build up score via iterative aggregation but
you can also just type a lilypond string into a staff. we afford both types of
input and, indeed, two different ways of building up score. this is where we
should cite alan kay's smalltalk paper.

2.95 there's a design priority in here somewhere that what we want to do is
make it as easy as possible for people to implement their own factories. what
does this mean? it means that we want to make it as easy as possible for people
to implement their own code that outputs or creates intermediate level
structures or materials. (there's a realization here that people probabaly
don't find it interesting to make a single note. but people can find it totally
fascinating to make an intermediate-level object like a complete phrase of
music.) 

3. we make it easy to build up complex score objects through iterative
aggregation.

3.15 we think it's important that users of the system should always have access
to an object-oriented interface to the graphic elements on the page.

3.2 we're committed to providing our users access to the full inventory of
symbols of conventional musical notation. (by contrast, we're not committed to
affording the drawing of arbitrary lines or other vectors.) in fact it's
interesting because what we seem to be committed to is letting users
instantiate conventionally semantic objects. and we're not at all committed to
letting users instantiate *nonsemantic* (that is, "purely graphic") objects.

3.5 we think it's important that users have access to all the features of the
underlying typesetter. (this is definitely a design committment and a
development committment.) this definitely comes from working with lilypond.

4. "selection flexability". we think it's important for composers to be able to
select arbitrary collections of score objects. this is important for a couple
of reasons. first, so that composers can map operations to the entirety of such
a selection at one time. second, there's some type of conceptual benefit to be
had in named selections; the point is that every selection is an ad hoc
intermediate structure created in the midst of the score. we also think it's
important to afford composers the ability to reference score objects in
whatever ways are most natural for a given task. sometimes the most natural
mode of reference is numeric, sometimes by name or sometimes by music-specific
criteria such as the relative times at which different objects appear in the
score. examples follow.

5. we think it's important for composers to be able to define an operation
(where musical or notational) one time and be able to apply the operation to
arbitrarily many objects in the score at once. of the many ways abjad provides
of doing this, the most important (and most general) is iteration. examples
follow. iteration can be glossed as "define-once, apply-many".

6. "configuration reuse". we think it's important for composers to be able to
configure objects a single time, and then resuse the configuration as many
times as necessary while composing. we also think it's important to configure
complex objects all at once.

6.5 "templating". we think it's important for composers to be able to template
all objects in the system, especially the hugely complex objects.

7. "statelessness". we think it's important that things should be stateless
whenever possible. this is why we provide the top-level new() function.

5. we provide a variety of ways of iterating over a score. 

6. we think it's really important to rely as much as possible on a well-known
and well-understood existent programming langauge.

7. we provide concrete object models of hierarchical relationships in the
score.

8. we provide concrete object models of temporal relationships in the score.

9. we provide concrete object models of vertical relationships in the score.

10. we try to follow the best practices of the open-source community (which has
a number of subpoints). 