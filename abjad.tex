\documentclass{article}
\usepackage{tenor2015}
\usepackage{times}
\usepackage{ifpdf}
\usepackage[english]{babel}
\usepackage{cite}

\usepackage{inconsolata}
\usepackage{verbatim}

\usepackage{listings}
\lstset{language=Python,
showspaces=false,
showtabs=false,
breaklines=false,
showstringspaces=false,
breakatwhitespace=false,
escapeinside={(*@}{@*)},
keywordstyle=\bfseries,
basicstyle=\scriptsize\ttfamily
}

\def\papertitle{Design Priorities in Abjad:
    A Python API for Formalized Score Control}
\def\firstauthor{Trevor Ba\v{c}a}
\def\secondauthor{Josiah Wolf Oberholtzer}
\def\thirdauthor{Jeffrey Trevi\~{n}o}
\def\fourthauthor{V\'{i}ctor Ad\'{a}n}

\newif\ifpdf
\ifx\pdfoutput\relax
\else
   \ifcase\pdfoutput
      \pdffalse
   \else
      \pdftrue
\fi

\ifpdf % compiling with pdflatex
  \usepackage[pdftex,
    pdftitle={\papertitle},
    pdfauthor={\firstauthor, \secondauthor, \thirdauthor, \fourthauthor},
    bookmarksnumbered, % use section numbers with bookmarks
    pdfstartview=XYZ % start with zoom=100% instead of full screen; 
                     % especially useful if working with a big screen :-)
   ]{hyperref}
  %\pdfcompresslevel=9

  \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are and their extensions so 
  %you won't have to specify these with every instance of \includegraphics
  \graphicspath{{./figures/}}
  \DeclareGraphicsExtensions{.pdf,.jpeg,.png}

  \usepackage[figure,table]{hypcap}

\else % compiling with latex
  \usepackage[dvips,
    bookmarksnumbered, % use section numbers with bookmarks
    pdfstartview=XYZ % start with zoom=100% instead of full screen
  ]{hyperref}  % hyperrefs are active in the pdf file after conversion
  \usepackage[dvips]{epsfig,graphicx}
  \graphicspath{{./figures/}}
  \DeclareGraphicsExtensions{.eps}
  \usepackage[figure,table]{hypcap}
\fi

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\title{\papertitle}

\fourauthors
  {\firstauthor} {Harvard University \\
    {\tt \href{mailto:trevor.baca@gmail.com}
        {trevor.baca@gmail.com}}}
  {\secondauthor} {Harvard University \\
    {\tt \href{mailto:josiah.oberholtzer@gmail.com}
        {josiah.oberholtzer@gmail.com}}}
  {\thirdauthor} {Carleton College \\
    {\tt \href{mailto:jeffrey.trevino@gmail.com}
        {jeffrey.trevino@gmail.com}}}
  {\fourthauthor} { 
    {\tt \href{mailto:vctradn@gmail.com}
        {vctradn@gmail.com}}}

\begin{document}

\capstartfalse
\maketitle
\capstarttrue

\begin{abstract}
Abjad\footnote{www.projectabjad.org} is an interactive open-source software
system designed to help composers build up complex pieces of music notation in
an iterative and incremental way.  Abjad is implemented in the
Python\footnote{www.python.org} programming language and architected as an
object-oriented collection of packages, classes and functions. Composers can
visualize their work as publication-quality score at all stages of the
compositional process using Abjad's interface to the
LilyPond\footnote{www.lilypond.org} music notation package. Although the first
versions of Abjad were implemented in 1997 and the project website is now
visited thousands of times each month, we have never documented the design
priorities that have guided us as we have built the system. In this paper we
detail some of the most important principles we have followed in our work
architecting Abjad. The priorities we document here arise in answer to
domain-specific questions of music modeling (what are the fundamental elements
of music notation? which elements of music notation should be modeled
hierarchically? which programming constructs are available to help model the
temporal relationships arising between entities in musical score?) as well as
in consideration of the ways in which best practices taken from software
engineering can apply to the development of a music software system like ours
(which programming concepts concerning things like iteration, aggregation and
encapsulation make sense to make available to composers? which existing tools
to test, document and deploy other open-source projects are available to help
develop a music software system like Abjad?). In the sections that follow we
discuss the background and motivations that lead us to ask questions like these
and then elaborate the design priorities we have arrived at in our ongoing work
architecting Abjad.
\end{abstract}

\input{background.tex}
%\input{notational_reality.tex}
%\input{notational_isomorphism.tex}
%\input{score_addressability.tex}
%\input{relationship_modeling.tex}
%\input{open_source.tex}

\section{NO DSLs}.
we think it's really important to rely as much as possible on a well-known
and well-understood existent programming langauge. no domain-specific languages
(dsls). music people always think they need a dsl. everybody always makes that
mistake. extend existing language. [TREVOR]

\section{universal illustration}
it's important that composers be able to
illustrate all objects they work with as they compose. this design priority is
reflected in the establishment of what we call the illustration protocol. this
priority is driven in large part by our shared insistence on the incredible
power of conventional music notation as a tool for thinking about sound and
time. (we wanna make it possible to illustrate everything all the time because
we notation helps us think about such incredibly complex stuff.) (footnote: we
think it's important that users have access to all the features of the
underlying typesetter.) [TREVOR]

\section{build bottom-up}
it's important for composers to be able to build complex
score bottom-up. input flexibility. you can build up score via iterative
aggregation but you can also just type a lilypond string into a staff. we
afford both types of input and, indeed, two different ways of building up
score. this is where we should cite alan kay's smalltalk paper. ("it's easy to
make a thing.") we make it easy to build up complex score objects through
iterative aggregation. ("we make it easy to build things up.") [JOSIAH]

\section{build top-down}
it's important for composers to be able to build complex
score top-down. we provide factories. factory functions. factory classes. when
we wanna make complex stuff we usually come up with factories. (there may be a
design principle here that initialization is kept simple and we implement in
factories complex ways of aggregating together objects that admit only simple
initialization.) (we generalize many of these things in processes.) there's a
design priority in here somewhere that what we want to do is make it as easy as
possible for people to implement their own factories. what does this mean? it
means that we want to make it as easy as possible for people to implement their
own code that outputs or creates intermediate level structures or materials.
(there's a realization here that people probabaly don't find it interesting to
make a single note. but people can find it totally fascinating to make an
intermediate-level object like a complete phrase of music.) we think it's
important for composers to be able to create their own processes that
generalize these things. with experience, use of the system migrates from
bottom-up to top-down: just look at us! this is what is closest to the work of
beginning to implement one's own system of composition. this is where we make
the case for esthethic-agnositicism. this is also an important point about
extensibility. [JOSIAH]

\section{selection flexability}
we think it's important for composers to be able to
select arbitrary collections of score objects. this is important for a couple
of reasons. first, so that composers can map operations to the entirety of such
a selection at one time. second, there's some type of conceptual benefit to be
had in named selections; the point is that every selection is an ad hoc
intermediate structure created in the midst of the score. we also think it's
important to afford composers the ability to reference score objects in
whatever ways are most natural for a given task. sometimes the most natural
mode of reference is numeric, sometimes by name or sometimes by music-specific
criteria such as the relative times at which different objects appear in the
score. examples follow. we provide concrete object models of vertical
relationships in the score. [TREVOR]

\section{configuration is super fucking important}
we think it's important for
composers to be able to define an operation (where musical or notational) one
time and be able to apply the operation to arbitrarily many objects in the
score at once. of the many ways abjad provides of doing this, the most
important (and most general) is iteration. examples follow. iteration can be
glossed as "define-once, apply-many". "configuration reuse". we think it's
important for composers to be able to configure objects a single time, and then
resuse the configuration as many times as necessary while composing. we also
think it's important to configure complex objects all at once. "templating". we
think it's important for composers to be able to template all objects in the
system, especially the hugely complex objects. [JOSIAH]

\section{encapsulation}
we want everything to be encapsulated as much as
possible. what this comes out to mean is the system is overwhelming
object-oriented (in the proper uses of the term) and that all parts of the
system (whether object-oriented or not) are structured in such a way as to
provide a single interface named according to a uniform set of naming
conventions. [TREVOR]

\section{open-source best practices}
we try to follow the best practices of the open-source community (which has
a number of subpoints). [TREVOR]

\section{conclusion}
we want composers to become programmers. for extremely good
reasons. and the priorities we have detailed here help make the case for why.
[TREVOR]

\bibliography{tenor2015}
\end{document}